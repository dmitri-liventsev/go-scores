// Code generated by goa v3.18.2, DO NOT EDIT.
//
// get by categories gRPC client types
//
// Command:
// $ goa gen go-scores/design

package client

import (
	getbycategories "go-scores/gen/get_by_categories"
	get_by_categoriespb "go-scores/gen/grpc/get_by_categories/pb"

	goa "goa.design/goa/v3/pkg"
)

// NewProtoGetAggregatedScoresRequest builds the gRPC request type from the
// payload of the "getAggregatedScores" endpoint of the "get by categories"
// service.
func NewProtoGetAggregatedScoresRequest(payload *getbycategories.GetAggregatedScoresPayload) *get_by_categoriespb.GetAggregatedScoresRequest {
	message := &get_by_categoriespb.GetAggregatedScoresRequest{
		From: payload.From,
		To:   payload.To,
	}
	return message
}

// NewGetAggregatedScoresResult builds the result type of the
// "getAggregatedScores" endpoint of the "get by categories" service from the
// gRPC response type.
func NewGetAggregatedScoresResult(message *get_by_categoriespb.GetAggregatedScoresResponse) *getbycategories.GetAggregatedScoresResult {
	result := &getbycategories.GetAggregatedScoresResult{}
	if message.Meta != nil {
		result.Meta = protobufGetByCategoriespbCategoryMetaToGetbycategoriesCategoryMeta(message.Meta)
	}
	if message.Data != nil {
		result.Data = make([]*getbycategories.CategoryScore, len(message.Data))
		for i, val := range message.Data {
			result.Data[i] = &getbycategories.CategoryScore{
				TotalScore: val.TotalScore,
			}
			if val.CategoryId != nil {
				categoryID := int(*val.CategoryId)
				result.Data[i].CategoryID = &categoryID
			}
			if val.NumOfReviews != nil {
				numOfReviews := int(*val.NumOfReviews)
				result.Data[i].NumOfReviews = &numOfReviews
			}
			if val.Periods != nil {
				result.Data[i].Periods = make([]*getbycategories.ScorePeriod, len(val.Periods))
				for j, val := range val.Periods {
					result.Data[i].Periods[j] = &getbycategories.ScorePeriod{
						Score: val.Score,
					}
					if val.Id != nil {
						id := int(*val.Id)
						result.Data[i].Periods[j].ID = &id
					}
				}
			}
		}
	}
	return result
}

// ValidateGetAggregatedScoresResponse runs the validations defined on
// GetAggregatedScoresResponse.
func ValidateGetAggregatedScoresResponse(message *get_by_categoriespb.GetAggregatedScoresResponse) (err error) {
	if message.Meta == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("meta", "message"))
	}
	if message.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "message"))
	}
	return
}

// svcGetbycategoriesCategoryMetaToGetByCategoriespbCategoryMeta builds a value
// of type *get_by_categoriespb.CategoryMeta from a value of type
// *getbycategories.CategoryMeta.
func svcGetbycategoriesCategoryMetaToGetByCategoriespbCategoryMeta(v *getbycategories.CategoryMeta) *get_by_categoriespb.CategoryMeta {
	res := &get_by_categoriespb.CategoryMeta{}
	if v.Periods != nil {
		res.Periods = make([]*get_by_categoriespb.Period, len(v.Periods))
		for i, val := range v.Periods {
			res.Periods[i] = &get_by_categoriespb.Period{
				Start: val.Start,
				End:   val.End,
			}
			if val.ID != nil {
				id := int32(*val.ID)
				res.Periods[i].Id = &id
			}
		}
	}
	if v.Categories != nil {
		res.Categories = make([]*get_by_categoriespb.Category, len(v.Categories))
		for i, val := range v.Categories {
			res.Categories[i] = &get_by_categoriespb.Category{
				Name: val.Name,
			}
			if val.ID != nil {
				id := int32(*val.ID)
				res.Categories[i].Id = &id
			}
		}
	}

	return res
}

// protobufGetByCategoriespbCategoryMetaToGetbycategoriesCategoryMeta builds a
// value of type *getbycategories.CategoryMeta from a value of type
// *get_by_categoriespb.CategoryMeta.
func protobufGetByCategoriespbCategoryMetaToGetbycategoriesCategoryMeta(v *get_by_categoriespb.CategoryMeta) *getbycategories.CategoryMeta {
	res := &getbycategories.CategoryMeta{}
	if v.Periods != nil {
		res.Periods = make([]*getbycategories.Period, len(v.Periods))
		for i, val := range v.Periods {
			res.Periods[i] = &getbycategories.Period{
				Start: val.Start,
				End:   val.End,
			}
			if val.Id != nil {
				id := int(*val.Id)
				res.Periods[i].ID = &id
			}
		}
	}
	if v.Categories != nil {
		res.Categories = make([]*getbycategories.Category, len(v.Categories))
		for i, val := range v.Categories {
			res.Categories[i] = &getbycategories.Category{
				Name: val.Name,
			}
			if val.Id != nil {
				id := int(*val.Id)
				res.Categories[i].ID = &id
			}
		}
	}

	return res
}
