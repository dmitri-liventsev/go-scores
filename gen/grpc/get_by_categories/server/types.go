// Code generated by goa v3.18.2, DO NOT EDIT.
//
// get by categories gRPC server types
//
// Command:
// $ goa gen go-scores/design

package server

import (
	getbycategories "go-scores/gen/get_by_categories"
	get_by_categoriespb "go-scores/gen/grpc/get_by_categories/pb"

	goa "goa.design/goa/v3/pkg"
)

// NewGetAggregatedScoresPayload builds the payload of the
// "getAggregatedScores" endpoint of the "get by categories" service from the
// gRPC request type.
func NewGetAggregatedScoresPayload(message *get_by_categoriespb.GetAggregatedScoresRequest) *getbycategories.GetAggregatedScoresPayload {
	v := &getbycategories.GetAggregatedScoresPayload{
		From: message.From,
		To:   message.To,
	}
	return v
}

// NewProtoGetAggregatedScoresResponse builds the gRPC response type from the
// result of the "getAggregatedScores" endpoint of the "get by categories"
// service.
func NewProtoGetAggregatedScoresResponse(result *getbycategories.GetAggregatedScoresResult) *get_by_categoriespb.GetAggregatedScoresResponse {
	message := &get_by_categoriespb.GetAggregatedScoresResponse{}
	if result.Meta != nil {
		message.Meta = svcGetbycategoriesCategoryMetaToGetByCategoriespbCategoryMeta(result.Meta)
	}
	if result.Data != nil {
		message.Data = make([]*get_by_categoriespb.CategoryScore, len(result.Data))
		for i, val := range result.Data {
			message.Data[i] = &get_by_categoriespb.CategoryScore{
				TotalScore: val.TotalScore,
			}
			if val.CategoryID != nil {
				categoryID := int32(*val.CategoryID)
				message.Data[i].CategoryId = &categoryID
			}
			if val.NumOfReviews != nil {
				numOfReviews := int32(*val.NumOfReviews)
				message.Data[i].NumOfReviews = &numOfReviews
			}
			if val.Periods != nil {
				message.Data[i].Periods = make([]*get_by_categoriespb.ScorePeriod, len(val.Periods))
				for j, val := range val.Periods {
					message.Data[i].Periods[j] = &get_by_categoriespb.ScorePeriod{
						Score: val.Score,
					}
					if val.ID != nil {
						id := int32(*val.ID)
						message.Data[i].Periods[j].Id = &id
					}
				}
			}
		}
	}
	return message
}

// ValidateGetAggregatedScoresRequest runs the validations defined on
// GetAggregatedScoresRequest.
func ValidateGetAggregatedScoresRequest(message *get_by_categoriespb.GetAggregatedScoresRequest) (err error) {
	err = goa.MergeErrors(err, goa.ValidateFormat("message.from", message.From, goa.FormatDate))
	err = goa.MergeErrors(err, goa.ValidatePattern("message.from", message.From, "^\\d{4}-\\d{2}-\\d{2}$"))
	err = goa.MergeErrors(err, goa.ValidateFormat("message.to", message.To, goa.FormatDate))
	err = goa.MergeErrors(err, goa.ValidatePattern("message.to", message.To, "^\\d{4}-\\d{2}-\\d{2}$"))
	return
}

// svcGetbycategoriesCategoryMetaToGetByCategoriespbCategoryMeta builds a value
// of type *get_by_categoriespb.CategoryMeta from a value of type
// *getbycategories.CategoryMeta.
func svcGetbycategoriesCategoryMetaToGetByCategoriespbCategoryMeta(v *getbycategories.CategoryMeta) *get_by_categoriespb.CategoryMeta {
	res := &get_by_categoriespb.CategoryMeta{}
	if v.Periods != nil {
		res.Periods = make([]*get_by_categoriespb.Period, len(v.Periods))
		for i, val := range v.Periods {
			res.Periods[i] = &get_by_categoriespb.Period{
				Start: val.Start,
				End:   val.End,
			}
			if val.ID != nil {
				id := int32(*val.ID)
				res.Periods[i].Id = &id
			}
		}
	}
	if v.Categories != nil {
		res.Categories = make([]*get_by_categoriespb.Category, len(v.Categories))
		for i, val := range v.Categories {
			res.Categories[i] = &get_by_categoriespb.Category{
				Name: val.Name,
			}
			if val.ID != nil {
				id := int32(*val.ID)
				res.Categories[i].Id = &id
			}
		}
	}

	return res
}

// protobufGetByCategoriespbCategoryMetaToGetbycategoriesCategoryMeta builds a
// value of type *getbycategories.CategoryMeta from a value of type
// *get_by_categoriespb.CategoryMeta.
func protobufGetByCategoriespbCategoryMetaToGetbycategoriesCategoryMeta(v *get_by_categoriespb.CategoryMeta) *getbycategories.CategoryMeta {
	res := &getbycategories.CategoryMeta{}
	if v.Periods != nil {
		res.Periods = make([]*getbycategories.Period, len(v.Periods))
		for i, val := range v.Periods {
			res.Periods[i] = &getbycategories.Period{
				Start: val.Start,
				End:   val.End,
			}
			if val.Id != nil {
				id := int(*val.Id)
				res.Periods[i].ID = &id
			}
		}
	}
	if v.Categories != nil {
		res.Categories = make([]*getbycategories.Category, len(v.Categories))
		for i, val := range v.Categories {
			res.Categories[i] = &getbycategories.Category{
				Name: val.Name,
			}
			if val.Id != nil {
				id := int(*val.Id)
				res.Categories[i].ID = &id
			}
		}
	}

	return res
}
